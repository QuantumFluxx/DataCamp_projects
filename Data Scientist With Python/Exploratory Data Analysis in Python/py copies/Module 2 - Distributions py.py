{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "39b788dc",
   "metadata": {},
   "source": [
    "# Distributions\n",
    "\n",
    "## Make a PMF\n",
    "The GSS dataset has been pre-loaded for you into a DataFrame called gss. You can explore it in the IPython Shell to get familiar with it.\n",
    "\n",
    "In this exercise, you'll focus on one variable in this dataset, 'year', which represents the year each respondent was interviewed.\n",
    "\n",
    "The Pmf class you saw in the video has already been created for you. You can access it outside of DataCamp via the `empiricaldist` library.\n",
    "\n",
    "* Make a `PMF` for year with `normalize=False` and display the result."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "633795c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "import h5py\n",
    "\n",
    "filename = \"datasets/gss.hdf5\"\n",
    "\n",
    "gss = h5py.File(filename,'r')\n",
    "\n",
    "from empiricaldist import Pmf\n",
    "\n",
    "# Compute the PMF for year\n",
    "pmf_year = Pmf(gss['year'], normalize=False)\n",
    "\n",
    "# Print the result\n",
    "print(pmf_year)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3e74432",
   "metadata": {},
   "source": [
    "* How many respondents were interviewed in 2016?\n",
    "\n",
    "* **2867**\n",
    "\n",
    "* 1613\n",
    "\n",
    "* 2538\n",
    "\n",
    "* 0.045897\n",
    "\n",
    "Correct. The PMF makes it easy to extract insights like this. Time now to visualize the PMF for the 'age' variable of this GSS dataset!\n",
    "\n",
    "## Plot a PMF\n",
    "Now let's plot a PMF for the age of the respondents in the GSS dataset. The variable 'age' contains respondents' age in years.\n",
    "\n",
    "* Select the 'age' column from the gss DataFrame and store the result in age."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "017e9625",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Select the age column\n",
    "age = gss['age']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c0471212",
   "metadata": {},
   "source": [
    "* Make a normalized PMF of age. Store the result in `pmf_age`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c3ef1ca8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Make a PMF of age\n",
    "pmf_age = Pmf(age)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6da60893",
   "metadata": {},
   "source": [
    "* Plot `pmf_age` as a bar chart."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21dd2641",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Plot the PMF\n",
    "pmf_age.bar()\n",
    "\n",
    "# Label the axes\n",
    "plt.xlabel('Age')\n",
    "plt.ylabel('PMF')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7831b0d0",
   "metadata": {},
   "source": [
    "Nice job. You could also use pmf_age.plot() to plot the Pmf as a line plot.\n",
    "\n",
    "## Make a CDF\n",
    "In this exercise, you'll make a CDF and use it to determine the fraction of respondents in the GSS dataset who are OLDER than 30.\n",
    "\n",
    "The GSS dataset has been preloaded for you into a DataFrame called gss.\n",
    "\n",
    "As with the Pmf class from the previous lesson, the Cdf class you just saw in the video has been created for you, and you can access it outside of DataCamp via the empiricaldist library.\n",
    "\n",
    "* Select the 'age' column. Store the result in age."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "64b32161",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Select the age column\n",
    "age = gss['age']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f659e961",
   "metadata": {},
   "source": [
    "* Compute the CDF of age. Store the result in `cdf_age`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "90e3b8df",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compute the CDF of age\n",
    "cdf_age = Cdf(age)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce66a2d5",
   "metadata": {},
   "source": [
    "* Calculate the CDF of 30."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "821eefaa",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate the CDF of 30\n",
    "print(cdf_age(30))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c607102e",
   "metadata": {},
   "source": [
    "What fraction of the respondents in the GSS dataset are OLDER than 30?\n",
    "\n",
    "* **Approximately 75%**\n",
    "\n",
    "* Approximately 65%\n",
    "\n",
    "* Approximately 45%\n",
    "\n",
    "* Approximately 25%\n",
    "\n",
    "You got it. Nice job!\n",
    "\n",
    "## Compute IQR\n",
    "Recall from the video that the interquartile range (IQR) is the difference between the 75th and 25th percentiles. It is a measure of variability that is robust in the presence of errors or extreme values.\n",
    "\n",
    "In this exercise, you'll compute the interquartile range of income in the GSS dataset. Income is stored in the 'realinc' column, and the CDF of income has already been computed and stored in cdf_income.\n",
    "\n",
    "* Calculate the 75th percentile of income and store it in `percentile_75th`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5de22ca8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate the 75th percentile \n",
    "percentile_75th = cdf_income.inverse(0.75)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd548f43",
   "metadata": {},
   "source": [
    "* Calculate the 25th percentile of income and store it in `percentile_25th`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fe8a9f96",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate the 25th percentile\n",
    "percentile_25th = cdf_income.inverse(0.25)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1b10ef1d",
   "metadata": {},
   "source": [
    "* Calculate the interquartile range of income. Store the result in iqr."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7d4b33d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate the interquartile range\n",
    "iqr = percentile_75th - percentile_25th\n",
    "\n",
    "# Print the interquartile range\n",
    "print(iqr)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83b9395c",
   "metadata": {},
   "source": [
    "What is the interquartile range (IQR) of income in the GSS dataset?\n",
    "\n",
    "* **Approximately 29676**\n",
    "\n",
    "* Approximately 26015\n",
    "\n",
    "* Approximately 34702\n",
    "\n",
    "* Approximately 30655\n",
    "\n",
    "That's it. Now, just one more exercise for this lesson.\n",
    "\n",
    "## Plot a CDF\n",
    "The distribution of income in almost every country is long-tailed; that is, there are a small number of people with very high incomes.\n",
    "\n",
    "In the GSS dataset, the variable 'realinc' represents total household income, converted to 1986 dollars. We can get a sense of the shape of this distribution by plotting the CDF.\n",
    "\n",
    "* Select 'realinc' from the gss dataset.\n",
    "* Make a Cdf object called cdf_income.\n",
    "* Create a plot of `cdf_income` using `.plot()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "57695821",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Select realinc\n",
    "income = gss['realinc']\n",
    "\n",
    "# Make the CDF\n",
    "cdf_income = Cdf(income)\n",
    "\n",
    "# Plot it\n",
    "cdf_income.plot()\n",
    "\n",
    "# Label the axes\n",
    "plt.xlabel('Income (1986 USD)')\n",
    "plt.ylabel('CDF')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "294b0edf",
   "metadata": {},
   "source": [
    "Excellent. You are ready for the next lesson, in which you'll learn how to compare distributions!\n",
    "\n",
    "## Distribution of education\n",
    "Let's begin comparing incomes for different levels of education in the GSS dataset, which has been pre-loaded for you into a DataFrame called gss. The variable educ represents the respondent's years of education.\n",
    "\n",
    "What fraction of respondents report that they have 12 years of education or fewer?\n",
    "\n",
    "* Approximately 22%\n",
    "\n",
    "* Approximately 31%\n",
    "\n",
    "* Approximately 47%\n",
    "\n",
    "* **Approximately 53%**\n",
    "\n",
    "Correct. If you evaluate the CDF at 12, you get the fraction of respondents with 12 or fewer years of eduction.\n",
    "\n",
    "## Extract education levels\n",
    "Let's create Boolean Series to identify respondents with different levels of education.\n",
    "\n",
    "In the U.S, 12 years of education usually means the respondent has completed high school (secondary education). A respondent with 14 years of education has probably completed an associate degree (two years of college); someone with 16 years has probably completed a bachelor's degree (four years of college).\n",
    "\n",
    "* Complete the line that identifies respondents with associate degrees, that is, people with 14 or more years of education but less than 16.\n",
    "* Complete the line that identifies respondents with 12 or fewer years of education.\n",
    "* Confirm that the mean of high is the fraction we computed in the previous exercise, about 53%."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7bd289f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Select educ\n",
    "educ = gss['educ']\n",
    "\n",
    "# Bachelor's degree\n",
    "bach = (educ >= 16)\n",
    "\n",
    "# Associate degree\n",
    "assc = (educ >= 14) & (educ < 16)\n",
    "\n",
    "# High school\n",
    "high = (educ <= 12)\n",
    "print(high.mean())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9f4ec11",
   "metadata": {},
   "source": [
    "Excellent. Remember, you can use logical operators to make Boolean Series and select rows from a DataFrame or Series.\n",
    "\n",
    "## Plot income CDFs\n",
    "Let's now see what the distribution of income looks like for people with different education levels. You can do this by plotting the CDFs. Recall how Allen plotted the income CDFs of respondents interviewed before and after 1995:\n",
    "```python\n",
    "Cdf(income[pre95]).plot(label='Before 1995')\n",
    "Cdf(income[~pre95]).plot(label='After 1995')\n",
    "```\n",
    "You can assume that Boolean Series have been defined, as in the previous exercise, to identify respondents with different education levels: high, assc, and bach.\n",
    "\n",
    "* Fill in the missing lines of code to plot the CDFs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c90589f2",
   "metadata": {},
   "outputs": [],
   "source": [
    "income = gss['realinc']\n",
    "\n",
    "# Plot the CDFs\n",
    "Cdf(income[high]).plot(label='High school')\n",
    "Cdf(income[assc]).plot(label='Associate')\n",
    "Cdf(income[bach]).plot(label='Bachelor')\n",
    "\n",
    "# Label the axes\n",
    "plt.xlabel('Income (1986 USD)')\n",
    "plt.ylabel('CDF')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2e9e288",
   "metadata": {},
   "source": [
    "Nice job. It might not be surprising that people with more education have higher incomes, but looking at these distributions, we can see where the differences are.\n",
    "\n",
    "## Distribution of income\n",
    "In many datasets, the distribution of income is approximately lognormal, which means that the logarithms of the incomes fit a normal distribution. We'll see whether that's true for the GSS data. As a first step, you'll compute the mean and standard deviation of the log of incomes using NumPy's `np.log10()` function.\n",
    "\n",
    "Then, you'll use the computed mean and standard deviation to make a norm object using the scipy.stats.norm() function.\n",
    "\n",
    "* Extract 'realinc' from gss and compute its logarithm using `np.log10()`.\n",
    "* Compute the mean and standard deviation of the result.\n",
    "* Make a norm object by passing the computed mean and standard deviation to `norm()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8468b35a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np \n",
    "\n",
    "# Extract realinc and compute its log\n",
    "income = gss['realinc']\n",
    "log_income = np.log10(income)\n",
    "\n",
    "# Compute mean and standard deviation\n",
    "mean = log_income.mean()\n",
    "std = log_income.std()\n",
    "print(mean, std)\n",
    "\n",
    "# Make a norm object\n",
    "from scipy.stats import norm\n",
    "dist = norm(mean, std)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c7edea51",
   "metadata": {},
   "source": [
    "Nice work. Now we can plot the model and the observed distribution and see where they differ.\n",
    "\n",
    "## Comparing CDFs\n",
    "To see whether the distribution of income is well modeled by a lognormal distribution, we'll compare the CDF of the logarithm of the data to a normal distribution with the same mean and standard deviation. These variables from the previous exercise are available for use:\n",
    "```python\n",
    "# Extract realinc and compute its log\n",
    "log_income = np.log10(gss['realinc'])\n",
    "\n",
    "# Compute mean and standard deviation\n",
    "mean, std = log_income.mean(), log_income.std()\n",
    "\n",
    "# Make a norm object\n",
    "from scipy.stats import norm\n",
    "dist = norm(mean, std)\n",
    "```\n",
    "dist is a `scipy.stats.norm` object with the same mean and standard deviation as the data. It provides `.cdf()`, which evaluates the normal cumulative distribution function.\n",
    "\n",
    "Be careful with capitalization: `Cdf()`, with an uppercase C, creates Cdf objects. `dist.cdf()`, with a lowercase c, evaluates the normal cumulative distribution function.\n",
    "\n",
    "* Evaluate the normal cumulative distribution function using `dist.cdf`.\n",
    "* Use the `Cdf()` function to compute the CDF of `log_income`.\n",
    "* Plot the result."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "720d5097",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Evaluate the model CDF\n",
    "xs = np.linspace(2, 5.5)\n",
    "ys = dist.cdf(xs)\n",
    "\n",
    "# Plot the model CDF\n",
    "plt.clf()\n",
    "plt.plot(xs, ys, color='gray')\n",
    "\n",
    "# Create and plot the Cdf of log_income\n",
    "Cdf(log_income).plot()\n",
    "    \n",
    "# Label the axes\n",
    "plt.xlabel('log10 of realinc')\n",
    "plt.ylabel('CDF')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "66db88d5",
   "metadata": {},
   "source": [
    "Good job. The lognormal model is a pretty good fit for the data, but clearly not a perfect match. That's what real data is like; sometimes it doesn't fit the model.\n",
    "\n",
    "## Comparing PDFs\n",
    "In the previous exercise, we used CDFs to see if the distribution of income is lognormal. We can make the same comparison using a PDF and KDE. That's what you'll do in this exercise!\n",
    "\n",
    "As before, the norm object dist is available in your workspace:\n",
    "```python\n",
    "from scipy.stats import norm\n",
    "dist = norm(mean, std)\n",
    "```\n",
    "Just as all norm objects have a `.cdf()` method, they also have a `.pdf()` method.\n",
    "\n",
    "To create a KDE plot, you can use Seaborn's `kdeplot()` function. Here, Seaborn has been imported for you as sns.\n",
    "\n",
    "* Evaluate the normal PDF using dist, which is a norm object with the same mean and standard deviation as the data.\n",
    "* Make a KDE plot of the logarithms of the incomes, using log_income, which is a Series object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2601562d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Evaluate the normal PDF\n",
    "xs = np.linspace(2, 5.5)\n",
    "ys = dist.pdf(xs)\n",
    "\n",
    "# Plot the model PDF\n",
    "plt.clf()\n",
    "plt.plot(xs, ys, color='gray')\n",
    "\n",
    "# Plot the data KDE\n",
    "sns.kdeplot(log_income)\n",
    "    \n",
    "# Label the axes\n",
    "plt.xlabel('log10 of realinc')\n",
    "plt.ylabel('PDF')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9c537f69",
   "metadata": {},
   "source": [
    "Congratulations on completing Chapter 2! We've seen several ways to vizualize and compare distributions: PMFs, CDFs, and KDE plots. In the next Chapter we'll explore relationships between variables, starting with heights and weights from a large survey of adults in the U.S. See you there!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
